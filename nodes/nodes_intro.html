<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nodes and workflows &mdash; sisl 0.1.dev1+gf943161 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Toolboxes" href="../toolbox/index.html" />
    <link rel="prev" title="stoolbox" href="../scripts/stoolbox.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            sisl
          </a>
              <div class="version">
                0.1.dev1+gf943161
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other.html">Other resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications using sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/scripts.html">Command line scripts</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Nodes and workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Nodes">Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Workflows">Workflows</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../visualization/ase/index.html">ASE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../visualization/viz_module/index.html">The <code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Nodes and workflows</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/nodes/nodes_intro.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars and line breaks on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
    white-space: pre;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div align="right">
Download IPython notebook <a href="https://raw.githubusercontent.com/zerothi/sisl/master//home/runner/work/sisl/sisl/docs/nodes/nodes_intro.ipynb"> here</a>.
<span style="white-space: nowrap;"><a href="https://mybinder.org/v2/gh/zerothi/sisl/master?filepath=/home/runner/work/sisl/sisl/docs/nodes/nodes_intro.ipynb"><img alt="Binder badge" src="https://mybinder.org/badge_logo.svg" style="vertical-align:text-bottom"></a>.</span>
</div><section id="Nodes-and-workflows">
<h1>Nodes and workflows<a class="headerlink" href="#Nodes-and-workflows" title="Permalink to this heading"></a></h1>
<p>Nodes and workflows are a functionality within <code class="docutils literal notranslate"><span class="pre">sisl</span></code> that allows you to define functional workflows that are lazily computed in a very easy way. Some of the reasons that you might want to use the <code class="docutils literal notranslate"><span class="pre">sisl.nodes</span></code> framework are:</p>
<ul class="simple">
<li><p><strong>Cleaner and maintainable code</strong>: The framework forces to write your workflows in a functional style. That is, <strong>each piece of functionality</strong> must be packed into <strong>a node, which must be a pure function</strong>, i.e. a function whose result depends only on its inputs. If you manage to do this, your code will be much more reusable and reproduceable by other people. It also helps a lot in testing your code, since you can very easily test each piece individually.</p></li>
<li><p><strong>Easier to use by an external interface</strong>: Graphical interfaces (GUI) can have a hard time interacting with code if there is no clear division of functionalities or the inputs to provide are very complex. Nodes are pieces of functionality with simple input fields. Whenever an input to a node is too complex, you can always generate it from another node, simplifying the input that the user needs to provide. Linking a node’s output to another node’s input is therefore a very efficient way of
creating “workchains” from a GUI by providing only simple inputs.</p></li>
</ul>
<p><em>Note</em>: The plan is to convert <code class="docutils literal notranslate"><span class="pre">`sisl-gui</span></code> &lt;<a class="reference external" href="https://pypi.org/project/sisl-gui/">https://pypi.org/project/sisl-gui/</a>&gt;`__ to use these nodes and workflows, so whatever that you develope within the framework will be usable automatically by the GUI.</p>
<section id="Nodes">
<h2>Nodes<a class="headerlink" href="#Nodes" title="Permalink to this heading"></a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">sisl.nodes</span></code>, you have the <code class="docutils literal notranslate"><span class="pre">Node</span></code> class:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sisl</span>
<span class="kn">from</span> <span class="nn">sisl.nodes</span> <span class="kn">import</span> <span class="n">Node</span>
</pre></div>
</div>
</div>
<p>You can easily create a node from a function with the <code class="docutils literal notranslate"><span class="pre">from_func</span></code> method:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@Node</span><span class="o">.</span><span class="n">from_func</span>
<span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SUMMING </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Instead of using it as a decorator, if you want to keep the pristine function,</span>
<span class="c1"># you can always create the node later:</span>
<span class="c1">#</span>
<span class="c1"># def my_sum(a: int, b: int):</span>
<span class="c1">#     print(f&quot;SUMMING {a} + {b}&quot;)</span>
<span class="c1">#     return a + b</span>
<span class="c1">#</span>
<span class="c1"># my_sum_node = Node.from_func(my_sum)</span>
</pre></div>
</div>
</div>
<p>By default, <strong>nodes compute lazily</strong>. That is they only run when you explicitly ask for the result. Therefore, calling your node won’t run the function, it will just create a new node instance.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.my_sum at 0x7f0b8875f4f0&gt;
</pre></div></div>
</div>
<p>It is only when you call <code class="docutils literal notranslate"><span class="pre">.get()</span></code> on it that it will compute its result.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 2 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
7
</pre></div></div>
</div>
<p>The result is then stored in the node, and if you keep requesting it the node will not need to recompute, it will just return the result:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This won&#39;t execute the function, so we won&#39;t see the printed message.</span>
<span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
7
</pre></div></div>
</div>
<p>Nodes will typically be part of a workflow. If you want to change an input in a section of your workflow, you should not need to substitute your node. Therefore, nodes have a method to change inputs:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.my_sum at 0x7f0b8875f5e0&gt;
</pre></div></div>
</div>
<p>And now, when you need the value again, it will understand that the stored output is outdated and recompute:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 8 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
13
</pre></div></div>
</div>
<p>You can also set a node’s special <code class="docutils literal notranslate"><span class="pre">automatic_recalc</span></code> input to <code class="docutils literal notranslate"><span class="pre">True</span></code>. In this way, each time the input is changed, the node will recompute.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">auto_result</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">automatic_recalc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">auto_result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="n">auto_result</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 2 + 5
SUMMING 8 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.my_sum at 0x7f0b8875fcd0&gt;
</pre></div></div>
</div>
<p>And now comes the most useful thing about nodes. If you pass a node as an input to another node, the <strong>nodes are recursively resolved</strong> until they reach a leaf that is not a node.</p>
<p>In the following example, we will create a node that depends on another node. We will see that whenever you need the result for the final node, all its dependencies are computed.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute a first value</span>
<span class="n">first_val</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># Use the first value to compute our final value</span>
<span class="n">final_val</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">first_val</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">final_val</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 2 + 5
SUMMING 7 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
12
</pre></div></div>
</div>
<p>Exactly as in the case where we had only one node, if you update the inputs of any node, the results also get recomputed when the value is requested.</p>
<p>In the following example we update the input of the first node. When we request the output of the last node, the first node goes like “Wait a moment, I am outdated, I need to recompute my value”. Then when the value is recomputed, the final node goes on to also recompute its value with the new input.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">first_val</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">final_val</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 7 + 5
SUMMING 12 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
17
</pre></div></div>
</div>
<p>And if a node doesn’t need to be recomputed, it will just return the stored output. In the following cell we update the inputs of our second node, but the first one still has the same inputs and therefore doesn’t need to recompute:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">final_val</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">final_val</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 12 + 20
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
32
</pre></div></div>
</div>
<p>When nodes are passed as inputs, they are not only recursively resolved. A <strong>connection</strong> between them is made so that they can <strong>propagate information through the tree</strong>. That is, when a node updates its inputs, it will send a signal up the tree that its output is outdated. In this way, if some node up the tree wants automatic recalculation, it will trigger a recompute of himself, which will recursively reach the outdated node.</p>
<p>Let’s create again two nodes, but this time the final one will have automatic recalculation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute a first value</span>
<span class="n">first_val</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1"># Use the first value to compute our final value, which we want to</span>
<span class="c1"># automatically recompute when there are changes.</span>
<span class="n">final_val</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">first_val</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">automatic_recalc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Get the value</span>
<span class="n">final_val</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 2 + 5
SUMMING 7 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
12
</pre></div></div>
</div>
<p>Now, when we update the inputs of the first node, the second one will notice, and it will trigger a recompute on all the tree, just as if we had called its <code class="docutils literal notranslate"><span class="pre">.get()</span></code> method.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Update the inputs of the first node, which will trigger recalculation</span>
<span class="n">first_val</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 7 + 5
SUMMING 12 + 5
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.my_sum at 0x7f0b8875f910&gt;
</pre></div></div>
</div>
<p>This might be useful to create “event listeners” that enable live updating naturally. We might introduce “async” nodes at some point (?).</p>
</section>
<section id="Workflows">
<h2>Workflows<a class="headerlink" href="#Workflows" title="Permalink to this heading"></a></h2>
<p>At this point, the need for somehow packing the workchain that we created arises naturally. What you would usually do is to wrap your code into a function. And that is also what we do here. We call this wrapper function a workflow, and workflows can be created just as nodes are:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sisl.nodes</span> <span class="kn">import</span> <span class="n">Workflow</span>

<span class="k">def</span> <span class="nf">my_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SUMMING </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Define our workchain as a workflow.</span>
<span class="nd">@Workflow</span><span class="o">.</span><span class="n">from_func</span>
<span class="k">def</span> <span class="nf">triple_sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">first_val</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">first_val</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

<span class="c1"># Again, if you want to keep the pristine function,</span>
<span class="c1"># don&#39;t use the decorator</span>
<span class="c1">#</span>
<span class="c1"># def triple_sum(a: int, b: int, c: int):</span>
<span class="c1">#    first_val = my_sum(a, b)</span>
<span class="c1">#    return my_sum(first_val, c)</span>
<span class="c1">#</span>
<span class="c1"># my_workflow = Workflow.from_func(triple_sum)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
warn:0: SislWarning: Decorators are ignored for now on workflow creation. Ignoring 1 decorators on triple_sum
</pre></div></div>
</div>
<p>When a workflow is defined, the nodes within it are discovered and stored in <code class="docutils literal notranslate"><span class="pre">dryrun_nodes</span></code>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">wf_nodes</span> <span class="o">=</span> <span class="n">triple_sum</span><span class="o">.</span><span class="n">dryrun_nodes</span>
<span class="n">wf_nodes</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.workflow.WorkflowNodes at 0x7f0bc0364fd0&gt;
</pre></div></div>
</div>
<p>You can print them to get an idea of the nodes that you have there:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">wf_nodes</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Inputs: {&#39;a&#39;: &lt;sisl.nodes.workflow.WorkflowInput object at 0x7f0bc0358f40&gt;, &#39;b&#39;: &lt;sisl.nodes.workflow.WorkflowInput object at 0x7f0bc0358ee0&gt;, &#39;c&#39;: &lt;sisl.nodes.workflow.WorkflowInput object at 0x7f0bc0358f70&gt;}

Workers: {&#39;my_sum&#39;: &lt;sisl.nodes.node.my_sum object at 0x7f0bc0358a00&gt;, &#39;my_sum_1&#39;: &lt;sisl.nodes.node.my_sum object at 0x7f0bc0358790&gt;}

Output: &lt;sisl.nodes.workflow.WorkflowOutput object at 0x7f0bc0358820&gt;

Named nodes: {&#39;first_val&#39;: &#39;my_sum&#39;}
</pre></div></div>
</div>
<p>One important thing that you can see here is that the workflow gives names to the nodes that it uses so that it can easily find them when needed. The name is usually just the node’s name, but if there are multiple nodes of the same type it can get a bit more messy, because it adds a suffix <code class="docutils literal notranslate"><span class="pre">_1</span></code>, <code class="docutils literal notranslate"><span class="pre">_2</span></code>, <code class="docutils literal notranslate"><span class="pre">_3</span></code>…</p>
<p>For that reason, it is always a good idea to give more human understandable names to nodes. On workflow creation, <strong>variable assignments are automatically discovered</strong>, and the workflow uses the name of the variable as an alias to find the node. In this way, you can very easily give more meaningful names to nodes so that you can find them afterwards!</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">wf_nodes</span><span class="o">.</span><span class="n">first_val</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.my_sum at 0x7f0bc0358a00&gt;
</pre></div></div>
</div>
<p>Accessing nodes of the workflows is nice, but often it is <strong>difficult to get an idea of the whole workflow</strong> if it gets a bit complex.</p>
<p>It is always easier to <strong>understand the workflow by visualizing it</strong>. For that, you can use the <code class="docutils literal notranslate"><span class="pre">visualize</span></code> method of its <code class="docutils literal notranslate"><span class="pre">network</span></code> attribute, but you need <code class="docutils literal notranslate"><span class="pre">networkx</span></code> and <code class="docutils literal notranslate"><span class="pre">pyvis</span></code> installed in your computer, which you can install through <code class="docutils literal notranslate"><span class="pre">pip</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">triple_sum</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">notebook</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/opt/hostedtoolcache/Python/3.9.16/x64/lib/python3.9/site-packages/IPython/core/display.py:431: UserWarning: Consider using IPython.display.IFrame instead
  warnings.warn(&#34;Consider using IPython.display.IFrame instead&#34;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<iframe height='600px' srcdoc="&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;

            &lt;script&gt;function neighbourhoodHighlight(params) {
  // console.log(&quot;in nieghbourhoodhighlight&quot;);
  allNodes = nodes.get({ returnType: &quot;Object&quot; });
  // originalNodes = JSON.parse(JSON.stringify(allNodes));
  // if something is selected:
  if (params.nodes.length &gt; 0) {
    highlightActive = true;
    var i, j;
    var selectedNode = params.nodes[0];
    var degrees = 2;

    // mark all nodes as hard to read.
    for (let nodeId in allNodes) {
      // nodeColors[nodeId] = allNodes[nodeId].color;
      allNodes[nodeId].color = &quot;rgba(200,200,200,0.5)&quot;;
      if (allNodes[nodeId].hiddenLabel === undefined) {
        allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var allConnectedNodes = [];

    // get the second degree nodes
    for (i = 1; i &lt; degrees; i++) {
      for (j = 0; j &lt; connectedNodes.length; j++) {
        allConnectedNodes = allConnectedNodes.concat(
          network.getConnectedNodes(connectedNodes[j])
        );
      }
    }

    // all second degree nodes get a different color and their label back
    for (i = 0; i &lt; allConnectedNodes.length; i++) {
      // allNodes[allConnectedNodes[i]].color = &quot;pink&quot;;
      allNodes[allConnectedNodes[i]].color = &quot;rgba(150,150,150,0.75)&quot;;
      if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[allConnectedNodes[i]].label =
          allNodes[allConnectedNodes[i]].hiddenLabel;
        allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // all first degree nodes get their own color and their label back
    for (i = 0; i &lt; connectedNodes.length; i++) {
      // allNodes[connectedNodes[i]].color = undefined;
      allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
      if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[connectedNodes[i]].label =
          allNodes[connectedNodes[i]].hiddenLabel;
        allNodes[connectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // the main node gets its own color and its label back.
    // allNodes[selectedNode].color = undefined;
    allNodes[selectedNode].color = nodeColors[selectedNode];
    if (allNodes[selectedNode].hiddenLabel !== undefined) {
      allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
      allNodes[selectedNode].hiddenLabel = undefined;
    }
  } else if (highlightActive === true) {
    // console.log(&quot;highlightActive was true&quot;);
    // reset all nodes
    for (let nodeId in allNodes) {
      // allNodes[nodeId].color = &quot;purple&quot;;
      allNodes[nodeId].color = nodeColors[nodeId];
      // delete allNodes[nodeId].color;
      if (allNodes[nodeId].hiddenLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
        allNodes[nodeId].hiddenLabel = undefined;
      }
    }
    highlightActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length &gt; 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    // console.log(&quot;Nothing was selected&quot;);
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        // allNodes[nodeId].color = {};
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function filterHighlight(params) {
  allNodes = nodes.get({ returnType: &quot;Object&quot; });
  // if something is selected:
  if (params.nodes.length &gt; 0) {
    filterActive = true;
    let selectedNodes = params.nodes;

    // hiding all nodes and saving the label
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = true;
      if (allNodes[nodeId].savedLabel === undefined) {
        allNodes[nodeId].savedLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }

    for (let i=0; i &lt; selectedNodes.length; i++) {
      allNodes[selectedNodes[i]].hidden = false;
      if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
        allNodes[selectedNodes[i]].label = allNodes[selectedNodes[i]].savedLabel;
        allNodes[selectedNodes[i]].savedLabel = undefined;
      }
    }

  } else if (filterActive === true) {
    // reset all nodes
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = false;
      if (allNodes[nodeId].savedLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].savedLabel;
        allNodes[nodeId].savedLabel = undefined;
      }
    }
    filterActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length &gt; 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function selectNode(nodes) {
  network.selectNodes(nodes);
  neighbourhoodHighlight({ nodes: nodes });
  return nodes;
}

function selectNodes(nodes) {
  network.selectNodes(nodes);
  filterHighlight({nodes: nodes});
  return nodes;
}

function highlightFilter(filter) {
  let selectedNodes = []
  let selectedProp = filter[&#x27;property&#x27;]
  if (filter[&#x27;item&#x27;] === &#x27;node&#x27;) {
    let allNodes = nodes.get({ returnType: &quot;Object&quot; });
    for (let nodeId in allNodes) {
      if (allNodes[nodeId][selectedProp] &amp;&amp; filter[&#x27;value&#x27;].includes((allNodes[nodeId][selectedProp]).toString())) {
        selectedNodes.push(nodeId)
      }
    }
  }
  else if (filter[&#x27;item&#x27;] === &#x27;edge&#x27;){
    let allEdges = edges.get({returnType: &#x27;object&#x27;});
    // check if the selected property exists for selected edge and select the nodes connected to the edge
    for (let edge in allEdges) {
      if (allEdges[edge][selectedProp] &amp;&amp; filter[&#x27;value&#x27;].includes((allEdges[edge][selectedProp]).toString())) {
        selectedNodes.push(allEdges[edge][&#x27;from&#x27;])
        selectedNodes.push(allEdges[edge][&#x27;to&#x27;])
      }
    }
  }
  selectNodes(selectedNodes)
}&lt;/script&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css&quot; integrity=&quot;sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; /&gt;
            &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js&quot; integrity=&quot;sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/script&gt;








&lt;center&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;/center&gt;

&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/vis/dist/vis.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../node_modules/vis/dist/vis.js&quot;&gt; &lt;/script&gt;--&gt;
        &lt;link
          href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css&quot;
          rel=&quot;stylesheet&quot;
          integrity=&quot;sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6&quot;
          crossorigin=&quot;anonymous&quot;
        /&gt;
        &lt;script
          src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js&quot;
          integrity=&quot;sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf&quot;
          crossorigin=&quot;anonymous&quot;
        &gt;&lt;/script&gt;


        &lt;center&gt;
          &lt;h1&gt;&lt;/h1&gt;
        &lt;/center&gt;
        &lt;style type=&quot;text/css&quot;&gt;

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }






        &lt;/style&gt;
    &lt;/head&gt;


    &lt;body&gt;
        &lt;div class=&quot;card&quot; style=&quot;width: 100%&quot;&gt;


            &lt;div id=&quot;mynetwork&quot; class=&quot;card-body&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;




        &lt;script type=&quot;text/javascript&quot;&gt;

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : &#x27;&#x27;,
                  property : &#x27;&#x27;,
                  value : []
              };





              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById(&#x27;mynetwork&#x27;);



                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{&quot;color&quot;: &quot;#fde725&quot;, &quot;font&quot;: {}, &quot;id&quot;: &quot;my_sum_1&quot;, &quot;label&quot;: &quot;my_sum_1&quot;, &quot;level&quot;: 3.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;circle&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: my_sum\nNo documentation\n............................................\nautomatic_recalc = False\na = Linked( my_sum.output )\nb = Linked( triple_sum.c )\n&quot;}, {&quot;color&quot;: &quot;pink&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;output&quot;, &quot;label&quot;: &quot;Output&quot;, &quot;level&quot;: 4.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowOutput\nNo documentation\n............................................\nautomatic_recalc = False\nvalue = Linked( my_sum_1.output )\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;a&quot;, &quot;label&quot;: &quot;Input(a)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = a\n&quot;}, {&quot;color&quot;: &quot;#440154&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;white&quot;}, &quot;id&quot;: &quot;my_sum&quot;, &quot;label&quot;: &quot;first_val&quot;, &quot;level&quot;: 2.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;circle&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: my_sum\nNo documentation\n............................................\nautomatic_recalc = False\na = Linked( triple_sum.a )\nb = Linked( triple_sum.b )\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;b&quot;, &quot;label&quot;: &quot;Input(b)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = b\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;c&quot;, &quot;label&quot;: &quot;Input(c)&quot;, &quot;level&quot;: 2.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = c\n&quot;}]);
                  edges = new vis.DataSet([{&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;my_sum_1&quot;, &quot;label&quot;: &quot;value&quot;, &quot;title&quot;: &quot;my_sum() -\u003e WorkflowOutput.value&quot;, &quot;to&quot;: &quot;output&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;a&quot;, &quot;label&quot;: &quot;a&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e my_sum.a&quot;, &quot;to&quot;: &quot;my_sum&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;my_sum&quot;, &quot;label&quot;: &quot;a&quot;, &quot;title&quot;: &quot;my_sum() -\u003e my_sum.a&quot;, &quot;to&quot;: &quot;my_sum_1&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;b&quot;, &quot;label&quot;: &quot;b&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e my_sum.b&quot;, &quot;to&quot;: &quot;my_sum&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;c&quot;, &quot;label&quot;: &quot;b&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e my_sum.b&quot;, &quot;to&quot;: &quot;my_sum_1&quot;, &quot;width&quot;: 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: &quot;Object&quot; });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: &quot;Object&quot; });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    &quot;configure&quot;: {
        &quot;enabled&quot;: false
    },
    &quot;edges&quot;: {
        &quot;color&quot;: {
            &quot;inherit&quot;: true
        },
        &quot;smooth&quot;: {
            &quot;enabled&quot;: true,
            &quot;type&quot;: &quot;dynamic&quot;
        }
    },
    &quot;interaction&quot;: {
        &quot;dragNodes&quot;: true,
        &quot;hideEdgesOnDrag&quot;: false,
        &quot;hideNodesOnDrag&quot;: false
    },
    &quot;layout&quot;: {
        &quot;hierarchical&quot;: {
            &quot;blockShifting&quot;: true,
            &quot;edgeMinimization&quot;: true,
            &quot;enabled&quot;: true,
            &quot;levelSeparation&quot;: 150,
            &quot;parentCentralization&quot;: true,
            &quot;sortMethod&quot;: &quot;hubsize&quot;,
            &quot;treeSpacing&quot;: 200
        },
        &quot;improvedLayout&quot;: true,
        &quot;randomSeed&quot;: 0
    },
    &quot;physics&quot;: {
        &quot;enabled&quot;: true,
        &quot;stabilization&quot;: {
            &quot;enabled&quot;: true,
            &quot;fit&quot;: true,
            &quot;iterations&quot;: 1000,
            &quot;onlyDynamicEdges&quot;: false,
            &quot;updateInterval&quot;: 50
        }
    }
};






                  network = new vis.Network(container, data, options);










                  return network;

              }
              drawGraph();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;" style="width:100%"></iframe></div>
</div>
<p>There are many tweaks that you can try on the visualization, but we are not going to enter into the details. You can play with it to find the most appropiate representation!</p>
<p>Workflows are just a way of organizing nodes, so they work exactly the same. By default, they are lazy, so calling your workflow class will just get you an instance:</p>
<p>Workflows are, unlike nodes, lazy by default. So when you call a workflow, you get a workflow instance:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">triple_sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">result</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.triple_sum at 0x7f0b88197eb0&gt;
</pre></div></div>
</div>
<p>And then whenever you ask for the value, the workflow runs.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 2 + 3
SUMMING 5 + 4
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
9
</pre></div></div>
</div>
<p>Workflows link their inputs to inputs of the nodes they contain. In this way, if you update some input of the workflow, only the nodes that used that input will get updated, and only the necessary recomputation will be performed, exactly as we saw before.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.triple_sum at 0x7f0b88197eb0&gt;
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 5 + 8
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
13
</pre></div></div>
</div>
<p>Once the workflow has been instantiated, it will contain <strong>instantiated nodes</strong>, which are different from the nodes that are produced during the discovery run.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">nodes</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.workflow.WorkflowNodes at 0x7f0b88197550&gt;
</pre></div></div>
</div>
<p>One can imagine <strong>reusing their result for something else</strong>.</p>
<p>As an example, we can create an automatically recalculating node that will just inform us whenever the intermediate value changes</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@Node</span><span class="o">.</span><span class="n">from_func</span>
<span class="k">def</span> <span class="nf">alert_change</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">automatic_recalc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;VALUE CHANGED, it now is </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># We feed the node that produces the intermediate value into our alert node</span>
<span class="n">my_alert</span> <span class="o">=</span> <span class="n">alert_change</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">first_val</span><span class="p">)</span>


<span class="c1"># Now when we update the inputs of the workflow, the node will propagate the information through</span>
<span class="c1"># our new node.</span>
<span class="n">result</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 10 + 3
VALUE CHANGED, it now is 13
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;sisl.nodes.node.triple_sum at 0x7f0b88197eb0&gt;
</pre></div></div>
</div>
<p>It sometimes might be useful to provide methods for a workflow. For that case, workflows can also be defined with class syntax, passing the workflow as a static method in the <code class="docutils literal notranslate"><span class="pre">_workflow</span></code> method.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TripleSum</span><span class="p">(</span><span class="n">Workflow</span><span class="p">):</span>

    <span class="c1"># Define the function that runs the workflow, exactly as we did before.</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_workflow</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">first_val</span> <span class="o">=</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">my_sum</span><span class="p">(</span><span class="n">first_val</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="c1"># Now, we have the possibility of adding new methods to it.</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_inputs</span><span class="p">(</span>
            <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_input</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span>
            <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_input</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span><span class="p">,</span>
            <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_input</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span>
        <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
warn:0: SislWarning: Decorators are ignored for now on workflow creation. Ignoring 1 decorators on _workflow
</pre></div></div>
</div>
<p>We can now use the workflow exactly as we did before.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">TripleSum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 2 + 3
SUMMING 5 + 4
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
9
</pre></div></div>
</div>
<p>But with the added possibility of using this useful provided method:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
SUMMING 8 + 12
SUMMING 20 + 16
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
36
</pre></div></div>
</div>
<p>It is important to know that <strong>whatever calculation that you do in your workflow’s code</strong> will be <strong>reconverted to a node</strong>. This means that its inputs and outputs are stored. As a not so obvious example, if you sum three values, the intermediate sum will be stored as a node:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@Workflow</span><span class="o">.</span><span class="n">from_func</span>
<span class="k">def</span> <span class="nf">sum_triple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="n">sum_triple</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">notebook</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
warn:0: SislWarning: Decorators are ignored for now on workflow creation. Ignoring 1 decorators on sum_triple
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<iframe height='600px' srcdoc="&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;

            &lt;script&gt;function neighbourhoodHighlight(params) {
  // console.log(&quot;in nieghbourhoodhighlight&quot;);
  allNodes = nodes.get({ returnType: &quot;Object&quot; });
  // originalNodes = JSON.parse(JSON.stringify(allNodes));
  // if something is selected:
  if (params.nodes.length &gt; 0) {
    highlightActive = true;
    var i, j;
    var selectedNode = params.nodes[0];
    var degrees = 2;

    // mark all nodes as hard to read.
    for (let nodeId in allNodes) {
      // nodeColors[nodeId] = allNodes[nodeId].color;
      allNodes[nodeId].color = &quot;rgba(200,200,200,0.5)&quot;;
      if (allNodes[nodeId].hiddenLabel === undefined) {
        allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var allConnectedNodes = [];

    // get the second degree nodes
    for (i = 1; i &lt; degrees; i++) {
      for (j = 0; j &lt; connectedNodes.length; j++) {
        allConnectedNodes = allConnectedNodes.concat(
          network.getConnectedNodes(connectedNodes[j])
        );
      }
    }

    // all second degree nodes get a different color and their label back
    for (i = 0; i &lt; allConnectedNodes.length; i++) {
      // allNodes[allConnectedNodes[i]].color = &quot;pink&quot;;
      allNodes[allConnectedNodes[i]].color = &quot;rgba(150,150,150,0.75)&quot;;
      if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[allConnectedNodes[i]].label =
          allNodes[allConnectedNodes[i]].hiddenLabel;
        allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // all first degree nodes get their own color and their label back
    for (i = 0; i &lt; connectedNodes.length; i++) {
      // allNodes[connectedNodes[i]].color = undefined;
      allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
      if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[connectedNodes[i]].label =
          allNodes[connectedNodes[i]].hiddenLabel;
        allNodes[connectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // the main node gets its own color and its label back.
    // allNodes[selectedNode].color = undefined;
    allNodes[selectedNode].color = nodeColors[selectedNode];
    if (allNodes[selectedNode].hiddenLabel !== undefined) {
      allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
      allNodes[selectedNode].hiddenLabel = undefined;
    }
  } else if (highlightActive === true) {
    // console.log(&quot;highlightActive was true&quot;);
    // reset all nodes
    for (let nodeId in allNodes) {
      // allNodes[nodeId].color = &quot;purple&quot;;
      allNodes[nodeId].color = nodeColors[nodeId];
      // delete allNodes[nodeId].color;
      if (allNodes[nodeId].hiddenLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
        allNodes[nodeId].hiddenLabel = undefined;
      }
    }
    highlightActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length &gt; 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    // console.log(&quot;Nothing was selected&quot;);
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        // allNodes[nodeId].color = {};
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function filterHighlight(params) {
  allNodes = nodes.get({ returnType: &quot;Object&quot; });
  // if something is selected:
  if (params.nodes.length &gt; 0) {
    filterActive = true;
    let selectedNodes = params.nodes;

    // hiding all nodes and saving the label
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = true;
      if (allNodes[nodeId].savedLabel === undefined) {
        allNodes[nodeId].savedLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }

    for (let i=0; i &lt; selectedNodes.length; i++) {
      allNodes[selectedNodes[i]].hidden = false;
      if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
        allNodes[selectedNodes[i]].label = allNodes[selectedNodes[i]].savedLabel;
        allNodes[selectedNodes[i]].savedLabel = undefined;
      }
    }

  } else if (filterActive === true) {
    // reset all nodes
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = false;
      if (allNodes[nodeId].savedLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].savedLabel;
        allNodes[nodeId].savedLabel = undefined;
      }
    }
    filterActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length &gt; 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function selectNode(nodes) {
  network.selectNodes(nodes);
  neighbourhoodHighlight({ nodes: nodes });
  return nodes;
}

function selectNodes(nodes) {
  network.selectNodes(nodes);
  filterHighlight({nodes: nodes});
  return nodes;
}

function highlightFilter(filter) {
  let selectedNodes = []
  let selectedProp = filter[&#x27;property&#x27;]
  if (filter[&#x27;item&#x27;] === &#x27;node&#x27;) {
    let allNodes = nodes.get({ returnType: &quot;Object&quot; });
    for (let nodeId in allNodes) {
      if (allNodes[nodeId][selectedProp] &amp;&amp; filter[&#x27;value&#x27;].includes((allNodes[nodeId][selectedProp]).toString())) {
        selectedNodes.push(nodeId)
      }
    }
  }
  else if (filter[&#x27;item&#x27;] === &#x27;edge&#x27;){
    let allEdges = edges.get({returnType: &#x27;object&#x27;});
    // check if the selected property exists for selected edge and select the nodes connected to the edge
    for (let edge in allEdges) {
      if (allEdges[edge][selectedProp] &amp;&amp; filter[&#x27;value&#x27;].includes((allEdges[edge][selectedProp]).toString())) {
        selectedNodes.push(allEdges[edge][&#x27;from&#x27;])
        selectedNodes.push(allEdges[edge][&#x27;to&#x27;])
      }
    }
  }
  selectNodes(selectedNodes)
}&lt;/script&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css&quot; integrity=&quot;sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; /&gt;
            &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js&quot; integrity=&quot;sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/script&gt;








&lt;center&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;/center&gt;

&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/vis/dist/vis.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../node_modules/vis/dist/vis.js&quot;&gt; &lt;/script&gt;--&gt;
        &lt;link
          href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css&quot;
          rel=&quot;stylesheet&quot;
          integrity=&quot;sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6&quot;
          crossorigin=&quot;anonymous&quot;
        /&gt;
        &lt;script
          src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js&quot;
          integrity=&quot;sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf&quot;
          crossorigin=&quot;anonymous&quot;
        &gt;&lt;/script&gt;


        &lt;center&gt;
          &lt;h1&gt;&lt;/h1&gt;
        &lt;/center&gt;
        &lt;style type=&quot;text/css&quot;&gt;

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }






        &lt;/style&gt;
    &lt;/head&gt;


    &lt;body&gt;
        &lt;div class=&quot;card&quot; style=&quot;width: 100%&quot;&gt;


            &lt;div id=&quot;mynetwork&quot; class=&quot;card-body&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;




        &lt;script type=&quot;text/javascript&quot;&gt;

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : &#x27;&#x27;,
                  property : &#x27;&#x27;,
                  value : []
              };





              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById(&#x27;mynetwork&#x27;);



                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{&quot;color&quot;: &quot;#fde725&quot;, &quot;font&quot;: {}, &quot;id&quot;: &quot;UfuncNode_1&quot;, &quot;label&quot;: &quot;val&quot;, &quot;level&quot;: 3.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;circle&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: UfuncNode\nNo documentation\n............................................\nautomatic_recalc = False\nkwargs = {\u0027input_0\u0027: \u0027Linked( UfuncNode.output )\u0027, \u0027input_1\u0027: \u0027Linked( sum_triple.c )\u0027}\nufunc = \u003cufunc \u0027add\u0027\u003e\nmethod = __call__\ninput_kwargs = {}\n&quot;}, {&quot;color&quot;: &quot;pink&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;output&quot;, &quot;label&quot;: &quot;Output&quot;, &quot;level&quot;: 4.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowOutput\nNo documentation\n............................................\nautomatic_recalc = False\nvalue = Linked( UfuncNode_1.output )\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;a&quot;, &quot;label&quot;: &quot;Input(a)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = a\n&quot;}, {&quot;color&quot;: &quot;#440154&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;white&quot;}, &quot;id&quot;: &quot;UfuncNode&quot;, &quot;label&quot;: &quot;UfuncNode&quot;, &quot;level&quot;: 2.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;circle&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: UfuncNode\nNo documentation\n............................................\nautomatic_recalc = False\nkwargs = {\u0027input_0\u0027: \u0027Linked( sum_triple.a )\u0027, \u0027input_1\u0027: \u0027Linked( sum_triple.b )\u0027}\nufunc = \u003cufunc \u0027add\u0027\u003e\nmethod = __call__\ninput_kwargs = {}\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;b&quot;, &quot;label&quot;: &quot;Input(b)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = b\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;c&quot;, &quot;label&quot;: &quot;Input(c)&quot;, &quot;level&quot;: 2.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = c\n&quot;}]);
                  edges = new vis.DataSet([{&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;UfuncNode_1&quot;, &quot;label&quot;: &quot;value&quot;, &quot;title&quot;: &quot;UfuncNode() -\u003e WorkflowOutput.value&quot;, &quot;to&quot;: &quot;output&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;a&quot;, &quot;label&quot;: &quot;kwargs[input_0]&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e UfuncNode.kwargs[input_0]&quot;, &quot;to&quot;: &quot;UfuncNode&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;UfuncNode&quot;, &quot;label&quot;: &quot;kwargs[input_0]&quot;, &quot;title&quot;: &quot;UfuncNode() -\u003e UfuncNode.kwargs[input_0]&quot;, &quot;to&quot;: &quot;UfuncNode_1&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;b&quot;, &quot;label&quot;: &quot;kwargs[input_1]&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e UfuncNode.kwargs[input_1]&quot;, &quot;to&quot;: &quot;UfuncNode&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;c&quot;, &quot;label&quot;: &quot;kwargs[input_1]&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e UfuncNode.kwargs[input_1]&quot;, &quot;to&quot;: &quot;UfuncNode_1&quot;, &quot;width&quot;: 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: &quot;Object&quot; });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: &quot;Object&quot; });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    &quot;configure&quot;: {
        &quot;enabled&quot;: false
    },
    &quot;edges&quot;: {
        &quot;color&quot;: {
            &quot;inherit&quot;: true
        },
        &quot;smooth&quot;: {
            &quot;enabled&quot;: true,
            &quot;type&quot;: &quot;dynamic&quot;
        }
    },
    &quot;interaction&quot;: {
        &quot;dragNodes&quot;: true,
        &quot;hideEdgesOnDrag&quot;: false,
        &quot;hideNodesOnDrag&quot;: false
    },
    &quot;layout&quot;: {
        &quot;hierarchical&quot;: {
            &quot;blockShifting&quot;: true,
            &quot;edgeMinimization&quot;: true,
            &quot;enabled&quot;: true,
            &quot;levelSeparation&quot;: 150,
            &quot;parentCentralization&quot;: true,
            &quot;sortMethod&quot;: &quot;hubsize&quot;,
            &quot;treeSpacing&quot;: 200
        },
        &quot;improvedLayout&quot;: true,
        &quot;randomSeed&quot;: 0
    },
    &quot;physics&quot;: {
        &quot;enabled&quot;: true,
        &quot;stabilization&quot;: {
            &quot;enabled&quot;: true,
            &quot;fit&quot;: true,
            &quot;iterations&quot;: 1000,
            &quot;onlyDynamicEdges&quot;: false,
            &quot;updateInterval&quot;: 50
        }
    }
};






                  network = new vis.Network(container, data, options);










                  return network;

              }
              drawGraph();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;" style="width:100%"></iframe></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sum_triple</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">to_pyvis</span><span class="p">(</span><span class="n">notebook</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;class &#39;pyvis.network.Network&#39;&gt; |N|=3 |E|=2
</pre></div></div>
</div>
<p>So if you don’t want that, you should pack everything that you don’t want to be saved in a separate function, and then use it in the workflow:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">operation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>

<span class="nd">@Workflow</span><span class="o">.</span><span class="n">from_func</span>
<span class="k">def</span> <span class="nf">sum_triple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">operation</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="n">sum_triple</span><span class="o">.</span><span class="n">network</span><span class="o">.</span><span class="n">visualize</span><span class="p">(</span><span class="n">notebook</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
warn:0: SislWarning: Decorators are ignored for now on workflow creation. Ignoring 1 decorators on sum_triple
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<iframe height='600px' srcdoc="&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;

            &lt;script&gt;function neighbourhoodHighlight(params) {
  // console.log(&quot;in nieghbourhoodhighlight&quot;);
  allNodes = nodes.get({ returnType: &quot;Object&quot; });
  // originalNodes = JSON.parse(JSON.stringify(allNodes));
  // if something is selected:
  if (params.nodes.length &gt; 0) {
    highlightActive = true;
    var i, j;
    var selectedNode = params.nodes[0];
    var degrees = 2;

    // mark all nodes as hard to read.
    for (let nodeId in allNodes) {
      // nodeColors[nodeId] = allNodes[nodeId].color;
      allNodes[nodeId].color = &quot;rgba(200,200,200,0.5)&quot;;
      if (allNodes[nodeId].hiddenLabel === undefined) {
        allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }
    var connectedNodes = network.getConnectedNodes(selectedNode);
    var allConnectedNodes = [];

    // get the second degree nodes
    for (i = 1; i &lt; degrees; i++) {
      for (j = 0; j &lt; connectedNodes.length; j++) {
        allConnectedNodes = allConnectedNodes.concat(
          network.getConnectedNodes(connectedNodes[j])
        );
      }
    }

    // all second degree nodes get a different color and their label back
    for (i = 0; i &lt; allConnectedNodes.length; i++) {
      // allNodes[allConnectedNodes[i]].color = &quot;pink&quot;;
      allNodes[allConnectedNodes[i]].color = &quot;rgba(150,150,150,0.75)&quot;;
      if (allNodes[allConnectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[allConnectedNodes[i]].label =
          allNodes[allConnectedNodes[i]].hiddenLabel;
        allNodes[allConnectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // all first degree nodes get their own color and their label back
    for (i = 0; i &lt; connectedNodes.length; i++) {
      // allNodes[connectedNodes[i]].color = undefined;
      allNodes[connectedNodes[i]].color = nodeColors[connectedNodes[i]];
      if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
        allNodes[connectedNodes[i]].label =
          allNodes[connectedNodes[i]].hiddenLabel;
        allNodes[connectedNodes[i]].hiddenLabel = undefined;
      }
    }

    // the main node gets its own color and its label back.
    // allNodes[selectedNode].color = undefined;
    allNodes[selectedNode].color = nodeColors[selectedNode];
    if (allNodes[selectedNode].hiddenLabel !== undefined) {
      allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
      allNodes[selectedNode].hiddenLabel = undefined;
    }
  } else if (highlightActive === true) {
    // console.log(&quot;highlightActive was true&quot;);
    // reset all nodes
    for (let nodeId in allNodes) {
      // allNodes[nodeId].color = &quot;purple&quot;;
      allNodes[nodeId].color = nodeColors[nodeId];
      // delete allNodes[nodeId].color;
      if (allNodes[nodeId].hiddenLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
        allNodes[nodeId].hiddenLabel = undefined;
      }
    }
    highlightActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length &gt; 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    // console.log(&quot;Nothing was selected&quot;);
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        // console.log(allNodes[nodeId]);
        // allNodes[nodeId].color = {};
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function filterHighlight(params) {
  allNodes = nodes.get({ returnType: &quot;Object&quot; });
  // if something is selected:
  if (params.nodes.length &gt; 0) {
    filterActive = true;
    let selectedNodes = params.nodes;

    // hiding all nodes and saving the label
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = true;
      if (allNodes[nodeId].savedLabel === undefined) {
        allNodes[nodeId].savedLabel = allNodes[nodeId].label;
        allNodes[nodeId].label = undefined;
      }
    }

    for (let i=0; i &lt; selectedNodes.length; i++) {
      allNodes[selectedNodes[i]].hidden = false;
      if (allNodes[selectedNodes[i]].savedLabel !== undefined) {
        allNodes[selectedNodes[i]].label = allNodes[selectedNodes[i]].savedLabel;
        allNodes[selectedNodes[i]].savedLabel = undefined;
      }
    }

  } else if (filterActive === true) {
    // reset all nodes
    for (let nodeId in allNodes) {
      allNodes[nodeId].hidden = false;
      if (allNodes[nodeId].savedLabel !== undefined) {
        allNodes[nodeId].label = allNodes[nodeId].savedLabel;
        allNodes[nodeId].savedLabel = undefined;
      }
    }
    filterActive = false;
  }

  // transform the object into an array
  var updateArray = [];
  if (params.nodes.length &gt; 0) {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  } else {
    for (let nodeId in allNodes) {
      if (allNodes.hasOwnProperty(nodeId)) {
        updateArray.push(allNodes[nodeId]);
      }
    }
    nodes.update(updateArray);
  }
}

function selectNode(nodes) {
  network.selectNodes(nodes);
  neighbourhoodHighlight({ nodes: nodes });
  return nodes;
}

function selectNodes(nodes) {
  network.selectNodes(nodes);
  filterHighlight({nodes: nodes});
  return nodes;
}

function highlightFilter(filter) {
  let selectedNodes = []
  let selectedProp = filter[&#x27;property&#x27;]
  if (filter[&#x27;item&#x27;] === &#x27;node&#x27;) {
    let allNodes = nodes.get({ returnType: &quot;Object&quot; });
    for (let nodeId in allNodes) {
      if (allNodes[nodeId][selectedProp] &amp;&amp; filter[&#x27;value&#x27;].includes((allNodes[nodeId][selectedProp]).toString())) {
        selectedNodes.push(nodeId)
      }
    }
  }
  else if (filter[&#x27;item&#x27;] === &#x27;edge&#x27;){
    let allEdges = edges.get({returnType: &#x27;object&#x27;});
    // check if the selected property exists for selected edge and select the nodes connected to the edge
    for (let edge in allEdges) {
      if (allEdges[edge][selectedProp] &amp;&amp; filter[&#x27;value&#x27;].includes((allEdges[edge][selectedProp]).toString())) {
        selectedNodes.push(allEdges[edge][&#x27;from&#x27;])
        selectedNodes.push(allEdges[edge][&#x27;to&#x27;])
      }
    }
  }
  selectNodes(selectedNodes)
}&lt;/script&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css&quot; integrity=&quot;sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; /&gt;
            &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js&quot; integrity=&quot;sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/script&gt;








&lt;center&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;/center&gt;

&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/vis/dist/vis.min.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../node_modules/vis/dist/vis.js&quot;&gt; &lt;/script&gt;--&gt;
        &lt;link
          href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css&quot;
          rel=&quot;stylesheet&quot;
          integrity=&quot;sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6&quot;
          crossorigin=&quot;anonymous&quot;
        /&gt;
        &lt;script
          src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js&quot;
          integrity=&quot;sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf&quot;
          crossorigin=&quot;anonymous&quot;
        &gt;&lt;/script&gt;


        &lt;center&gt;
          &lt;h1&gt;&lt;/h1&gt;
        &lt;/center&gt;
        &lt;style type=&quot;text/css&quot;&gt;

             #mynetwork {
                 width: 100%;
                 height: 600px;
                 background-color: #ffffff;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }






        &lt;/style&gt;
    &lt;/head&gt;


    &lt;body&gt;
        &lt;div class=&quot;card&quot; style=&quot;width: 100%&quot;&gt;


            &lt;div id=&quot;mynetwork&quot; class=&quot;card-body&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;




        &lt;script type=&quot;text/javascript&quot;&gt;

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : &#x27;&#x27;,
                  property : &#x27;&#x27;,
                  value : []
              };





              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById(&#x27;mynetwork&#x27;);



                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{&quot;color&quot;: &quot;#440154&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;white&quot;}, &quot;id&quot;: &quot;operation&quot;, &quot;label&quot;: &quot;val&quot;, &quot;level&quot;: 2.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;circle&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: operation\nNo documentation\n............................................\nautomatic_recalc = False\na = Linked( sum_triple.a )\nb = Linked( sum_triple.b )\nc = Linked( sum_triple.c )\n&quot;}, {&quot;color&quot;: &quot;pink&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;output&quot;, &quot;label&quot;: &quot;Output&quot;, &quot;level&quot;: 3.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowOutput\nNo documentation\n............................................\nautomatic_recalc = False\nvalue = Linked( operation.output )\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;a&quot;, &quot;label&quot;: &quot;Input(a)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = a\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;b&quot;, &quot;label&quot;: &quot;Input(b)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = b\n&quot;}, {&quot;color&quot;: &quot;#ccc&quot;, &quot;font&quot;: {&quot;color&quot;: &quot;black&quot;}, &quot;id&quot;: &quot;c&quot;, &quot;label&quot;: &quot;Input(c)&quot;, &quot;level&quot;: 1.0, &quot;mass&quot;: 2, &quot;shape&quot;: &quot;box&quot;, &quot;size&quot;: 10, &quot;title&quot;: &quot;Node class: WorkflowInput\nNo documentation\n............................................\nvalue = \u003cobject object at 0x7f0b88cf1840\u003e\nautomatic_recalc = False\ninput_key = c\n&quot;}]);
                  edges = new vis.DataSet([{&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;operation&quot;, &quot;label&quot;: &quot;value&quot;, &quot;title&quot;: &quot;operation() -\u003e WorkflowOutput.value&quot;, &quot;to&quot;: &quot;output&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;a&quot;, &quot;label&quot;: &quot;a&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e operation.a&quot;, &quot;to&quot;: &quot;operation&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;b&quot;, &quot;label&quot;: &quot;b&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e operation.b&quot;, &quot;to&quot;: &quot;operation&quot;, &quot;width&quot;: 1}, {&quot;arrows&quot;: &quot;to&quot;, &quot;from&quot;: &quot;c&quot;, &quot;label&quot;: &quot;c&quot;, &quot;title&quot;: &quot;WorkflowInput() -\u003e operation.c&quot;, &quot;to&quot;: &quot;operation&quot;, &quot;width&quot;: 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: &quot;Object&quot; });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: &quot;Object&quot; });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    &quot;configure&quot;: {
        &quot;enabled&quot;: false
    },
    &quot;edges&quot;: {
        &quot;color&quot;: {
            &quot;inherit&quot;: true
        },
        &quot;smooth&quot;: {
            &quot;enabled&quot;: true,
            &quot;type&quot;: &quot;dynamic&quot;
        }
    },
    &quot;interaction&quot;: {
        &quot;dragNodes&quot;: true,
        &quot;hideEdgesOnDrag&quot;: false,
        &quot;hideNodesOnDrag&quot;: false
    },
    &quot;layout&quot;: {
        &quot;hierarchical&quot;: {
            &quot;blockShifting&quot;: true,
            &quot;edgeMinimization&quot;: true,
            &quot;enabled&quot;: true,
            &quot;levelSeparation&quot;: 150,
            &quot;parentCentralization&quot;: true,
            &quot;sortMethod&quot;: &quot;hubsize&quot;,
            &quot;treeSpacing&quot;: 200
        },
        &quot;improvedLayout&quot;: true,
        &quot;randomSeed&quot;: 0
    },
    &quot;physics&quot;: {
        &quot;enabled&quot;: true,
        &quot;stabilization&quot;: {
            &quot;enabled&quot;: true,
            &quot;fit&quot;: true,
            &quot;iterations&quot;: 1000,
            &quot;onlyDynamicEdges&quot;: false,
            &quot;updateInterval&quot;: 50
        }
    }
};






                  network = new vis.Network(container, data, options);










                  return network;

              }
              drawGraph();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;" style="width:100%"></iframe></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../scripts/stoolbox.html" class="btn btn-neutral float-left" title="stoolbox" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../toolbox/index.html" class="btn btn-neutral float-right" title="Toolboxes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2023, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>